/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Cpp4Web"] = factory();
	else
		root["Cpp4Web"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Fundamental/Constant.js":
/*!*************************************!*\
  !*** ./src/Fundamental/Constant.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ControllType: () => (/* binding */ ControllType),\n/* harmony export */   TokenType: () => (/* binding */ TokenType),\n/* harmony export */   keyWords: () => (/* binding */ keyWords),\n/* harmony export */   signs: () => (/* binding */ signs)\n/* harmony export */ });\nconst keyWords = [\"int\", \"void\", \"double\", \"float\", \"short\", \"char\", \"bool\", \"long\", \"signed\", \"unsigned\", \"string\",\r\n\"asm\",\"do\",\"if\",\"return\",\"typedef\",\"auto\",\"inline\",\"typeid\",\"dynamic_cast\",\"typename\",\r\n\"break\",\"else\",\"sizeof\",\"union\",\"case\",\"enum\",\"mutable\",\"static\",\"catch\",\"explicit\",\"namespace\",\"static_cast\",\r\n\"using\",\"export\",\"new\",\"struct\",\"virtual\",\"class\",\"extern\",\"operator\",\"switch\",\"const\",\"false\",\"private\",\"template\",\r\n\"volatile\",\"const_cast\",\"protected\",\"this\",\"wchar_t\",\"continue\",\"for\",\"public\",\"throw\",\"while\",\"default\",\"friend\",\"register\",\"true\",\r\n\"delete\",\"goto\",\"reinterpret_cast\",\"try\",];\r\n\r\nconst signs = [\"==\", \"<<=\", \">>=\", \"*=\", \"+=\", \"~=\", \"-=\", \"/=\", \"|=\", \"^=\", \"%=\", \"&=\", \"=\", \"<<\", \">>\", \"#\", \"::\", \"?\", \":\", \">=\", \"<=\", \r\n\"<\", \">\", \"(\", \")\", \"->\", '...','\"',\"'\", \"!=\", '++', '--',\r\n\"{\", \"}\", ',', '+', '-', '*', '/', '~','||', '&&', '|', '&', '^', '%', '!', '[', ']', '.'];\r\n\r\nconst TokenType = {\r\n    identifier: 0,\r\n    number: 1,\r\n    keyword: 2,\r\n    sign: 3,\r\n    string: 4,\r\n    buildin: 5,\r\n    semicolon: 6,\r\n    char: 7,\r\n};\r\n\r\n\r\nconst ControllType = {\r\n    normal: 0,\r\n    continueState: 1,\r\n    breakState: 2,\r\n    returnState: 3,\r\n};\r\n\r\n\r\n/** @typedef {'TYPE_A'|'TYPE_B'} RuntimeTypeKeys */\r\n\r\n\n\n//# sourceURL=webpack://Cpp4Web/./src/Fundamental/Constant.js?");

/***/ }),

/***/ "./src/Fundamental/ParseFunctions.js":
/*!*******************************************!*\
  !*** ./src/Fundamental/ParseFunctions.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Parse: () => (/* binding */ Parse)\n/* harmony export */ });\n/* harmony import */ var _Constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Constant */ \"./src/Fundamental/Constant.js\");\n/* harmony import */ var _Parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Parser */ \"./src/Fundamental/Parser.js\");\n/* harmony import */ var runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! runtime */ \"./src/Fundamental/RuntimeType.development.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @returns {{ast: any}}\r\n */\r\nfunction emptyAST () {\r\n    return {ast: {type: runtime__WEBPACK_IMPORTED_MODULE_2__.empty}};\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseVariable = (parser) => {\r\n    const exp = parser.parseIdentify([]).ast;\r\n    const type = parser.variables.get(exp?.content);\r\n    if(!type) {\r\n        parser.error = `${exp?.content} is not a varibale`;\r\n        return parser;\r\n    }\r\n    return parser.setAST({\r\n        type: runtime__WEBPACK_IMPORTED_MODULE_2__.variable,\r\n        T: type,\r\n        content: exp.content\r\n    });\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseNumber = (parser) => {\r\n    const exp = parser.parseNumber().ast;\r\n    parser.setAST({\r\n        type: runtime__WEBPACK_IMPORTED_MODULE_2__.number,\r\n        content: exp.content,\r\n    });\r\n    return parser;\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseLValue = (parser) => {\r\n    let exp = emptyAST();\r\n    return parser.thenParse(parsePostfixExpression)\r\n                 .getAST(exp)\r\n                 .setAST({\r\n                    type: runtime__WEBPACK_IMPORTED_MODULE_2__.lValue,\r\n                    content: exp.ast,\r\n                 });\r\n}\r\n\r\n/**\r\n * @param {Array<string>} signs \r\n * @param {ParserFunction} nextParserFunction \r\n * @returns {ParserFunction}\r\n */\r\nconst parseBinaryOperations = (signs, nextParserFunction) => (parser) => {\r\n    const exp1 = parser.thenParse(nextParserFunction).ast;\r\n    return parser.reduce((_parser)=>{\r\n        const signWrapper = {}, exp2Wrapper = {};\r\n        return _parser.parseSign(signs).getAST(signWrapper)\r\n               .thenParse(nextParserFunction).getAST(exp2Wrapper)\r\n               .setAST({\r\n                    type: runtime__WEBPACK_IMPORTED_MODULE_2__.binaryOp,\r\n                    sign: signWrapper.ast.content,\r\n                    content: [_parser.meta.last, exp2Wrapper.ast],\r\n                });\r\n    }, exp1);\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseBool = (parser) => {\r\n\r\n    const value = parser.parseKeywords(['true', 'false']).ast.content;\r\n    return parser.setAST({\r\n        type: runtime__WEBPACK_IMPORTED_MODULE_2__.number,\r\n        content: value === 'true' ? '1':'0',\r\n    });\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseString = (parser) => {\r\n    const value = parser.parseSingle(_Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.string, []).ast.content;\r\n    return parser.setAST({\r\n        type: runtime__WEBPACK_IMPORTED_MODULE_2__.string,\r\n        content: value,\r\n    });\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseChar = (parser) => {\r\n    const value = parser.parseSingle(_Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.char, []).ast.content;\r\n    return parser.setAST({\r\n        type: runtime__WEBPACK_IMPORTED_MODULE_2__.string,\r\n        content: value,\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseInvoke = (parser) => {\r\n    const functionNameObj = {};\r\n    parser.choose([\r\n        [null, (_parser) => _parser.parseIdentify([])],\r\n        [null, (_parser) => _parser.parseSingle(_Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.buildin ,[])],\r\n    ]).getAST(functionNameObj);\r\n\r\n    const functionName = functionNameObj.ast?.content;\r\n    const tokenType = functionNameObj.ast?.type;\r\n    const func = parser.functions.get(functionName);\r\n    if(!func && tokenType === runtime__WEBPACK_IMPORTED_MODULE_2__.invoke) {\r\n        parser.error = `${functionName} is not a function`;\r\n        return parser;\r\n    }\r\n\r\n    const argus = parser.jumpSign(['(']).sequence((_parser)=>{\r\n        _parser.thenParse(parseAssignment);\r\n        if(!_parser.checkSign([')']))_parser.jumpSign([',']);\r\n        return _parser\r\n    }).jumpSign([')']).ast;\r\n    parser.setAST({\r\n        type: tokenType === _Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.buildin ? runtime__WEBPACK_IMPORTED_MODULE_2__.buildin:runtime__WEBPACK_IMPORTED_MODULE_2__.invoke,\r\n        functionName,\r\n        argus\r\n    });\r\n    return parser;\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parsePrimaryExpression = (parser) => {\r\n    return parser.choose([\r\n        [['('], (_parser) => _parser.jumpSign(['(']).thenParse(expression).jumpSign([')'])],\r\n        [['true', 'false'], parseBool],\r\n        [null, parseNumber],\r\n        [null, parseVariable],\r\n        [null, parseInvoke],\r\n        [null, parseString],\r\n        [null, parseChar],\r\n    ]);\r\n}\r\n\r\n/**\r\n * @param {Object} innerType \r\n * @returns {ParserFunction}\r\n */\r\nconst parseArrayDeclearation2 = (innerType) => (parser) => {\r\n\r\n    const index = emptyAST();\r\n    const inner = emptyAST();\r\n    return parser.choose([\r\n        [['['], (_parser) => _parser.jumpSign(['['])\r\n                                   .thenParse(expression).getAST(index)\r\n                                   .jumpSign([']'])\r\n                                   .thenParse(parseArrayDeclearation2(innerType)).getAST(inner)\r\n                                   .setAST({\r\n                                     type: runtime__WEBPACK_IMPORTED_MODULE_2__.arrayDeclearation,\r\n                                     inner: inner.ast,\r\n                                     parserIndex: index.ast\r\n                                   })\r\n        ],\r\n        [null, (_parser) => _parser.setAST(innerType)],\r\n    ]);\r\n}\r\n\r\n/**\r\n * @param {Object} innerType \r\n * @returns {ParserFunction}\r\n */\r\nconst parseArray2 = (innerType) => (parser) => {\r\n\r\n    const index = emptyAST();\r\n    const inner = emptyAST();\r\n    return parser.choose([\r\n        [['['], (_parser) => _parser.thenParse((_parser)=>{\r\n                                        if(innerType.type !== runtime__WEBPACK_IMPORTED_MODULE_2__.arrayDeclearation)return _parser.setError(\"type error\");\r\n                                        return _parser;\r\n                                    })\r\n                                    .jumpSign(['['])\r\n                                    .thenParse(expression).getAST(index)\r\n                                    .jumpSign([']'])\r\n                                    .thenParse(parseArray2(innerType)).getAST(inner)\r\n                                    .setAST({\r\n                                      type: runtime__WEBPACK_IMPORTED_MODULE_2__.array,\r\n                                      inner: inner.ast,\r\n                                      parserIndex: index.ast\r\n                                    })\r\n        ],\r\n        [['.'], (_parser) => _parser.thenParse((_parser)=>{return _parser;})\r\n                                    .jumpSign(['['])\r\n                                    .thenParse(expression).getAST(index)\r\n                                    .jumpSign([']'])\r\n                                    .thenParse(parseArray2(innerType)).getAST(inner)\r\n                                    .setAST({\r\n                                      type: runtime__WEBPACK_IMPORTED_MODULE_2__.array,\r\n                                      inner: inner.ast,\r\n                                      parserIndex: index.ast\r\n                                    })\r\n        ],\r\n        // @ts-ignore\r\n        [null, (_parser) => _parser.setAST(null)],\r\n    ]);\r\n}\r\n\r\n\r\n/**\r\n * @param {Object} type \r\n * @param {Object} variable \r\n * @returns {ParserFunction}\r\n */\r\nconst parsePostfix = (type, variable) => (parser) => {\r\n    if(type.type === runtime__WEBPACK_IMPORTED_MODULE_2__.arrayDeclearation) {\r\n        const primaryObj = emptyAST();\r\n        parser.thenParse(parseArray2(type)).getAST(primaryObj).setAST({\r\n            type: runtime__WEBPACK_IMPORTED_MODULE_2__.postfix,\r\n            sign: primaryObj.ast,\r\n            content: variable\r\n        });\r\n    } else if(type.type === 'struct') {\r\n        console.info(type);\r\n    } else\r\n        parser.setAST(variable);\r\n    return parser;\r\n}\r\n\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parsePostfixExpression = (parser) => {\r\n\r\n\r\n    const primaryObj = emptyAST();\r\n    return parser.thenParse(parsePrimaryExpression)\r\n                 .getAST(primaryObj)\r\n                 .thenParse((_parser) => {\r\n                     const primaryExp = primaryObj.ast;\r\n                     if(primaryExp.type === runtime__WEBPACK_IMPORTED_MODULE_2__.variable) {\r\n                         const type = primaryExp.T;\r\n                         parser.thenParse(parsePostfix(type, primaryExp))\r\n                     }\r\n\r\n                     if(parser.attempt((_parser) =>  _parser.parseSign(['++', '--']))) {\r\n                         parser.setAST({\r\n                             type: runtime__WEBPACK_IMPORTED_MODULE_2__.postfix,\r\n                             sign: parser.ast.content,\r\n                             content: primaryExp,\r\n                         });\r\n                     }\r\n                     return _parser;\r\n                 });\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parsePrefixExpression = (parser) => {\r\n    const unarySigns = [\"++\", \"--\", \"+\", \"-\", \"~\", \"!\", \"*\", \"&\"];\r\n    const sign = emptyAST(), exp = emptyAST();\r\n    return parser.choose([\r\n        [unarySigns, (_parser) => _parser.parseSign(unarySigns).getAST(sign).thenParse(parsePrefixExpression).getAST(exp)\r\n                                         .setAST({\r\n                                            type: runtime__WEBPACK_IMPORTED_MODULE_2__.prefix, \r\n                                            sign: sign.ast.content, \r\n                                            content: exp.ast\r\n                                        })],\r\n        [null, parsePostfixExpression]     \r\n    ]);\r\n\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseMultiplicative = (parser) => parser.thenParse(parseBinaryOperations([\"*\", \"/\", \"%\"], parsePrefixExpression));\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseAdditive = (parser) => parser.thenParse(parseBinaryOperations([\"+\", \"-\"], parseMultiplicative));\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseShift = (parser) => parser.thenParse(parseBinaryOperations([\"<<\", \">>\"], parseAdditive));\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseRelational = (parser) => parser.thenParse(parseBinaryOperations([\"<\", \">\", \"<=\", \">=\"], parseShift));\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseEuality = (parser) => parser.thenParse(parseBinaryOperations(['==', '!='], parseRelational));\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseAnd = (parser) => parser.thenParse(parseBinaryOperations(['&'], parseEuality));\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseXor = (parser) => parser.thenParse(parseBinaryOperations(['^'], parseAnd));\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseOr = (parser) => parser.thenParse(parseBinaryOperations(['|'], parseXor));\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseLogicalAnd = (parser) => parser.thenParse(parseBinaryOperations(['&&'], parseOr));\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseLogicalOr = (parser) => parser.thenParse(parseBinaryOperations(['||'], parseLogicalAnd));\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseConditionalExpression = (parser) => {\r\n    const condition = parser.thenParse(parseLogicalOr).ast;\r\n    // @ts-ignore\r\n    const result = parser.attempt((_parser) => {\r\n        const exp1 = _parser.jumpSign(['?']).thenParse(expression).jumpSign([':']).ast;\r\n        const exp2 = _parser.thenParse(expression).ast;\r\n        return _parser.setAST({\r\n            type: runtime__WEBPACK_IMPORTED_MODULE_2__.ternaryOp,\r\n            sign: \"?\",\r\n            content: [condition, exp1, exp2]\r\n        });\r\n    });\r\n    return parser;\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseAssignment = (parser) => {\r\n    const seq = parser.sequence((_parser)=>{\r\n        const lvalueWrapper = {}, signWrapper = {};\r\n        return _parser.thenParse(parseLValue).getAST(lvalueWrapper)\r\n               .parseSign(_Constant__WEBPACK_IMPORTED_MODULE_0__.signs.slice(1, 13)).getAST(signWrapper)\r\n               .setAST({\r\n                    type: runtime__WEBPACK_IMPORTED_MODULE_2__.binaryOp,\r\n                    sign: signWrapper.ast.content,\r\n                    content: [lvalueWrapper.ast],\r\n                });\r\n    }).ast;\r\n\r\n    const value = parser.thenParse(parseConditionalExpression).ast;\r\n    if(seq.length) {\r\n        for(let i = 0; i < seq.length-1; i++) {\r\n            seq[i].content.push(seq[i+1]);\r\n        }\r\n        seq[seq.length-1].content.push(value);\r\n        parser.setAST(seq[0]);\r\n    }\r\n    return parser;\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst expression = (parser) => {\r\n\r\n    let assignmentAst = parser.thenParse(parseAssignment).ast;\r\n    while(parser.checkSign([','])) {\r\n        parser.parseSign([',']);\r\n        assignmentAst = {\r\n            type: runtime__WEBPACK_IMPORTED_MODULE_2__.binaryOp,\r\n            sign: ',',\r\n            content: [assignmentAst, parser.thenParse(parseAssignment).ast],\r\n        };\r\n    }\r\n    // @ts-ignore\r\n    parser.setAST(assignmentAst);\r\n    return parser;\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst expressionStatement = (parser) => parser.thenParse(expression).jumpSemicolon();\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseStructType = (parser) => {\r\n    if(!parser.getStructOrUnion(parser.currentToken.content)) {\r\n        return parser.setError(\"not struct\");\r\n    }\r\n    return parser.parseIdentify([]).setAST({\r\n        type: runtime__WEBPACK_IMPORTED_MODULE_2__.type,\r\n        T: {\r\n            type: runtime__WEBPACK_IMPORTED_MODULE_2__.struct,\r\n            name: parser.currentToken.content,\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseType = (parser) => {\r\n    const PODs = _Constant__WEBPACK_IMPORTED_MODULE_0__.keyWords.slice(0,11);\r\n    const type = {};\r\n    return parser.choose([\r\n        [PODs, (_parser)=> _parser.parseKeywords(PODs).getAST(type).setAST( {type: runtime__WEBPACK_IMPORTED_MODULE_2__.type, T: {type: runtime__WEBPACK_IMPORTED_MODULE_2__.POD, name: type.ast}} )],\r\n        [null, parseStructType]\r\n    ]);\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseDeclearation = (parser) => {\r\n    const typeObj = emptyAST();\r\n    const type = parser.thenParse(parseType).ast?.T;\r\n    const seqObj = emptyAST();\r\n    return parser.sequence((_parser) => {\r\n        let variable = _parser.parseIdentify([]).ast;\r\n        const currentType = _parser.thenParse(parseArrayDeclearation2(type)).ast;\r\n        let value = null;\r\n        if(_parser.checkSign(['=']))value = _parser.jumpSign(['=']).thenParse(parseConditionalExpression).ast;\r\n        if(_parser.checkSign([',']))_parser.jumpSign([',']);\r\n        // @ts-ignore\r\n        _parser.setAST([variable, value, currentType]);\r\n        return _parser;\r\n    }).getAST(seqObj)\r\n    .thenParse((_parser) => {\r\n        if(_parser.checkSign(['('])) {\r\n            return _parser.setError(\"not variable\");\r\n        }\r\n        const seq = seqObj.ast;\r\n    \r\n        seq.forEach(element => {\r\n            parser.variables.set(element[0].content, element[2]);\r\n            parser.stack.push(element[0].content);\r\n        });\r\n        return _parser;\r\n    }).setAST({\r\n        type: runtime__WEBPACK_IMPORTED_MODULE_2__.declearation,\r\n        content: seqObj.ast\r\n    });\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseFor = (parser) => {\r\n    const initial = {};\r\n    const condition = {};\r\n    const increment = {};\r\n    const body = {};\r\n    return parser.parseKeywords(['for'])\r\n          .jumpSign(['('])\r\n          .choose([\r\n            [null, expressionStatement],\r\n            [null, parseDeclearation]\r\n          ]).jumpSemicolon().getAST(initial)\r\n          .thenParse(expression).jumpSemicolon().getAST(condition)\r\n          .thenParse(expression).getAST(increment)\r\n          .jumpSign([')'])\r\n          .choose([\r\n            [null, parseBlock],\r\n            [null, singleStatement]\r\n          ]).getAST(body)\r\n          .setAST({\r\n            type: runtime__WEBPACK_IMPORTED_MODULE_2__.forStmt,\r\n            initial: initial.ast,\r\n            condition: condition.ast,\r\n            increment: increment.ast,\r\n            body:body.ast,\r\n          });\r\n\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseWhile = (parser) => {\r\n    const condition = {};\r\n    const body = {};\r\n    return parser.parseKeywords(['while'])\r\n          .jumpSign(['('])\r\n          .thenParse(expression).getAST(condition)\r\n          .jumpSign([')'])\r\n          .choose([\r\n            [['{'], parseBlock],\r\n            [null, singleStatement]\r\n          ]).getAST(body)\r\n          .setAST({\r\n            type: runtime__WEBPACK_IMPORTED_MODULE_2__.whileStmt,\r\n            condition: condition.ast,\r\n            body:body.ast,\r\n          });\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseDoWhile = (parser) => {\r\n    const condition = emptyAST();;\r\n    const body = emptyAST();;\r\n    return parser.parseKeywords(['do'])\r\n          .thenParse(parseBlock).getAST(body)\r\n          .parseKeywords([\"while\"]).jumpSign(['('])\r\n          .thenParse(expression).getAST(condition)\r\n          .setAST({\r\n            type: runtime__WEBPACK_IMPORTED_MODULE_2__.doStmt,\r\n            condition: condition.ast,\r\n            body:body.ast,\r\n          });\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseIf = (parser) => {\r\n    const condition = {};\r\n    const body = {};\r\n    const elif = {};\r\n    const elses = {};\r\n    return parser.parseKeywords(['if'])\r\n                 .jumpSign(['(']).thenParse(expression).jumpSign([')']).getAST(condition)\r\n                 .choose([\r\n                    [['{'], parseBlock],\r\n                    [null, singleStatement]\r\n                  ]).getAST(body)\r\n                 .sequence((_parser) => {\r\n                    const condition = {};\r\n                    const body = {};\r\n                    return _parser.parseKeywords(['else']).parseKeywords(['if']).jumpSign(['('])\r\n                           .thenParse(expression).getAST(condition)\r\n                           .jumpSign([')'])\r\n                           .thenParse(parseBlock).getAST(body)\r\n                           // @ts-ignore\r\n                           .setAST({\r\n                              condition: condition.ast,\r\n                              body: body.ast\r\n                           });\r\n                 }).getAST(elif)\r\n                 .sequence((_parser) => _parser.parseKeywords(['else']).choose([\r\n                    [['{'], parseBlock],\r\n                    [null, singleStatement]\r\n                  ])).getAST(elses)\r\n                 .setAST({\r\n                    type: runtime__WEBPACK_IMPORTED_MODULE_2__.ifStmt,\r\n                    condition: condition.ast,\r\n                    body: body.ast,\r\n                    elif: elif.ast,\r\n                    elses: elses.ast[0]\r\n                 });\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseBreak = (parser) => parser.parseKeywords(['break']).jumpSemicolon().setAST({type: runtime__WEBPACK_IMPORTED_MODULE_2__.breakStmt});\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseContinue = (parser) => parser.parseKeywords(['continue']).jumpSemicolon().setAST({type: runtime__WEBPACK_IMPORTED_MODULE_2__.continueStmt});\r\n\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseReturn = (parser) => {\r\n    const exp = emptyAST();;\r\n    return parser.parseKeywords(['return'])\r\n                 .thenParse(expression).getAST(exp)\r\n                 .jumpSemicolon()\r\n                 .setAST({\r\n                    type: runtime__WEBPACK_IMPORTED_MODULE_2__.returnStmt,\r\n                    content: exp.ast,\r\n                 });\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst singleStatement = (parser) => parser.choose([\r\n    [['for'], parseFor],\r\n    [['while'], parseWhile],\r\n    [['do'], parseDoWhile],\r\n    [['if'], parseIf],\r\n    [['break'], parseBreak],\r\n    [['continue'], parseContinue],\r\n    [['return'], parseReturn],\r\n    [null, expressionStatement ],\r\n    [null, (_parser) => parseDeclearation(_parser).jumpSemicolon()],\r\n])\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseBlock = (parser) => {\r\n    parser.stack.push('{');\r\n    const seq = parser.jumpSign(['{']).sequence(singleStatement).jumpSign(['}']).ast;\r\n\r\n    while(parser.stack[parser.stack.length-1] != '{') {\r\n        parser.variables.delete(parser.stack[parser.stack.length-1]);\r\n        parser.stack.pop();\r\n    }\r\n    parser.stack.pop();\r\n    return parser.setAST({\r\n        type: runtime__WEBPACK_IMPORTED_MODULE_2__.blocks,\r\n        content:seq\r\n    });\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseFunction = (parser) => {\r\n    const returnType = {ast: {type: runtime__WEBPACK_IMPORTED_MODULE_2__.empty}};\r\n    const functioinNameObj = {ast: {type: runtime__WEBPACK_IMPORTED_MODULE_2__.empty}};\r\n    const blockObj = {ast: {type: runtime__WEBPACK_IMPORTED_MODULE_2__.empty}};\r\n    const parameters = {ast:{type: runtime__WEBPACK_IMPORTED_MODULE_2__.empty}};\r\n    let functionName = \"\";\r\n    return parser.thenParse(parseType).getAST(returnType)\r\n          .parseIdentify([]).getAST(functioinNameObj)\r\n          .thenParse((_parser) => {\r\n            const fn = functioinNameObj.ast;\r\n            functionName = fn.content;\r\n            parser.functions.set(functionName, {});\r\n            return _parser;\r\n          })\r\n          .jumpSign(['(']).sequence((_parser) => {\r\n             if(_parser.checkSign([')'])) {\r\n                 return _parser.setError(\"end\");\r\n             }\r\n             const type = _parser.thenParse(parseType).ast?.T;\r\n             const variable = _parser.parseIdentify([]).ast;\r\n            \r\n             parser.variables.set(variable.content, type);\r\n             parser.stack.push(variable.content);\r\n             _parser.ast = {type, variable};\r\n             if(!_parser.checkSign([')'])) {\r\n                 _parser.jumpSign([',']);\r\n             }\r\n             return _parser;\r\n          }).jumpSign([')']).getAST(parameters)\r\n          .thenParse(parseBlock).getAST(blockObj)\r\n          .thenParse((_parser) => {\r\n            _parser.functions.set(functionName, parser.ast);\r\n            return _parser\r\n          }).setAST({\r\n              type: runtime__WEBPACK_IMPORTED_MODULE_2__.functionStmt,\r\n              functionName,\r\n              returnType: returnType.ast,\r\n              parameters: parameters.ast,\r\n              body: blockObj.ast\r\n          });\r\n}\r\n\r\n/**\r\n * @param {Parser} parser \r\n * @returns {Parser}\r\n */\r\nconst parseProgram = (parser) => {\r\n    const globals = [];\r\n    const functions = new Map();\r\n    return parser.sequence((_) => _.choose([\r\n            [null, (_parser) => parseDeclearation(_parser).jumpSemicolon(), (_parser)=> {globals.push(_parser.ast);} ],\r\n            [null, parseFunction, (_parser)=> {functions.set(_parser.ast.functionName, _parser.ast);} ],\r\n        ])\r\n    ).thenParse((_parser) => {\r\n        if(!_parser.empty()) {\r\n            _parser.setError(_parser.meta.attemptErrorMessage);\r\n        }\r\n        return _parser\r\n    }).setAST({\r\n        type: runtime__WEBPACK_IMPORTED_MODULE_2__.program,\r\n        globals: globals,\r\n        functions: functions,\r\n        main: parser.functions.get('main'),\r\n        structs: null\r\n    });\r\n}\r\n\r\n/**\r\n * @param {TokenStream} stream \r\n * @returns {Object}\r\n */\r\nconst Parse = (stream) => {\r\n    const parser = new _Parser__WEBPACK_IMPORTED_MODULE_1__.Parser(stream);\r\n\r\n    const result = parseProgram(parser).ast;\r\n    if(parser.error) {\r\n        throw parser.error;\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://Cpp4Web/./src/Fundamental/ParseFunctions.js?");

/***/ }),

/***/ "./src/Fundamental/Parser.js":
/*!***********************************!*\
  !*** ./src/Fundamental/Parser.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Parser: () => (/* binding */ Parser)\n/* harmony export */ });\n/* harmony import */ var _Constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Constant */ \"./src/Fundamental/Constant.js\");\n\r\n/**\r\n * Represents a parser for some stream data.\r\n * @class\r\n * \r\n */\r\nclass Parser {\r\n\r\n    #stream\r\n\r\n    /**\r\n     * Creates a new Parser instance.\r\n     * @param {TokenStream} stream - The input stream.\r\n     * @param {number} [parserIndex=0] - The initial index.\r\n     */\r\n    constructor(stream, parserIndex) {\r\n        this.#stream = stream;\r\n        this.parserIndex = parserIndex ?? 0;\r\n        this.error = null;\r\n        this.structOrUnion = {};\r\n        this.ast = {};\r\n        this.meta = {};\r\n        this.variables = new Map();\r\n        this.stack = [];\r\n        this.functions = new Map();\r\n    }\r\n\r\n    /**\r\n     * Executes a parser function and updates the state.\r\n     * @param {ParserFunction} parserFunction - The parser function to execute.\r\n     * @returns {Parser} - The updated parser instance.\r\n     */\r\n    thenParse(parserFunction) {\r\n        if(!this.error) {\r\n            const ret = parserFunction(this);\r\n            if(!this.error) {\r\n                this.ast = ret.ast;\r\n                this.parserIndex = ret.parserIndex;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Attempts to execute a parser function without raising an error.\r\n     * @param {ParserFunction} parserFunction - The parser function to attempt.\r\n     * @returns {boolean} - `true` if successful, `false` otherwise.\r\n     */\r\n    attempt(parserFunction) {\r\n        if(!this.error) {\r\n            const parser = this.copy();\r\n            \r\n            const ret = parserFunction(parser);\r\n            if(!ret.error) {\r\n                this.ast = ret.ast;\r\n                this.parserIndex = ret.parserIndex;\r\n                return true;\r\n            }\r\n            this.meta.attemptErrorMessage = ret.error;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @param {AST} ast \r\n     * @returns {Parser}\r\n     */\r\n    setAST(ast) {\r\n        this.ast = ast;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {Object} obj \r\n     * @returns {Parser}\r\n     */\r\n    getAST(obj) {\r\n        obj.ast = this.ast;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {string} error \r\n     * @returns {Parser}\r\n     */\r\n    setError(error) {\r\n        this.ast = {};\r\n        this.error = error;\r\n        return this;\r\n    }\r\n\r\n\r\n    copy() {\r\n        const parser = new Parser(this.#stream, this.parserIndex);\r\n        parser.variables = this.variables;\r\n        parser.functions = this.functions;\r\n        parser.stack = this.stack;\r\n        return parser;\r\n    }\r\n\r\n    /**\r\n     * Executes a sequence and updates the state.\r\n     * @param {ParserFunction} parserFunction - The parser function to execute.\r\n     * @returns {Parser} - The updated parser instance.\r\n     */\r\n    sequence(parserFunction) {\r\n        const ast = [];\r\n        while(!this.empty()) {\r\n            const result = this.attempt((parser) => {\r\n                return parserFunction(parser);\r\n            });\r\n\r\n            if(result) {\r\n                ast.push(this.ast);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        this.ast = ast;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {ParserFunction} parserFunction\r\n     * @param {Object} initial\r\n     * @returns {Parser} - The updated parser instance.\r\n     */\r\n    reduce(parserFunction, initial) {\r\n        let last = initial;\r\n        while(true) {\r\n            const result = this.attempt((parser) => {\r\n                parser.meta.last = last;\r\n                return parserFunction(parser);\r\n            });\r\n\r\n            if(result) {\r\n                last = this.ast;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        this.ast = last;\r\n        return this;\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {Array<[null|Array<string>, ParserFunction, Function] | [null|Array<string>, ParserFunction]>} parserFunctions \r\n     * @returns {Parser}\r\n     */\r\n    choose(parserFunctions) {\r\n        if(this.error)return this;\r\n        for(const parserFunction of parserFunctions) {\r\n            const foresees = parserFunction[0];\r\n            const parserFunc = parserFunction[1];\r\n            const afterFunc = parserFunction[2];\r\n            if(foresees) {\r\n                for(const foresee of foresees) {\r\n                    if(this.currentToken.content === foresee && (this.currentToken.type === _Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.sign || this.currentToken.type === _Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.keyword)) {\r\n                        const result = parserFunc(this);\r\n                        if(afterFunc) afterFunc(this);\r\n                        return result;\r\n                    }\r\n                }\r\n            } else {\r\n                const result = this.attempt((parser) => {\r\n                    return parserFunc(parser);\r\n                });\r\n\r\n                if(result) {\r\n                    if(afterFunc) afterFunc(this);\r\n                    return this;\r\n                }\r\n            }\r\n        }\r\n        this.error = this.meta.attemptErrorMessage;\r\n        if(!this.error) {\r\n            this.error = \"stop\";\r\n        }\r\n        return this;\r\n    }\r\n\r\n\r\n    /**\r\n     * Parses a single token of the specified type.\r\n     * @param {number} type - The token type.\r\n     * @param {Array} contents - The expected token contents.\r\n     * @param {boolean} [jump=false] - Whether to advance the parserIndex.\r\n     * @returns {Parser} - The updated parser instance.\r\n     */\r\n    parseSingle = (type, contents, jump=false) => {\r\n        if(this.checkToken(type, contents)) {\r\n            if(!jump){\r\n                this.ast = {\r\n                    content: this.currentToken.content,\r\n                    type\r\n                };\r\n            }\r\n            this.parserIndex++;\r\n        } else this.error = `cannot find ${contents[0]} at line ${this.currentLine}`;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {Array<string>} keywords - The expected token contents.\r\n     * @returns {Parser} - The updated parser instance.\r\n     */\r\n    jumpSign = (keywords) => this.parseSingle(_Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.sign, keywords, true);\r\n\r\n    /**\r\n     * @param {Array<string>} keywords - The expected token contents.\r\n     * @returns {Parser} - The updated parser instance.\r\n     */\r\n    parseSign = (keywords) => this.parseSingle(_Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.sign, keywords);\r\n    \r\n    /**\r\n     * @returns {Parser} - The updated parser instance.\r\n     */\r\n    parseSemicolon = () => this.parseSingle(_Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.semicolon, []);\r\n    \r\n    /**\r\n     * @returns {Parser} - The updated parser instance.\r\n     */\r\n    jumpSemicolon = () => this.parseSingle(_Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.semicolon, [], true);\r\n\r\n    /**\r\n     * @param {Array<string>} keywords - The expected token contents.\r\n     * @returns {Parser} - The updated parser instance.\r\n     */\r\n    parseKeywords = (keywords) => this.parseSingle(_Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.keyword, keywords);\r\n\r\n    /**\r\n     * @returns {Parser} - The updated parser instance.\r\n     */\r\n    parseNumber = () => this.parseSingle(_Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.number, []);\r\n\r\n    /**\r\n     * @param {Array<string>} identify - The expected token contents.\r\n     * @returns {Parser} - The updated parser instance.\r\n     */\r\n    parseIdentify = (identify) => this.parseSingle(_Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.identifier, identify);\r\n\r\n    get currentToken() {\r\n        return this.#stream[this.parserIndex];\r\n    }\r\n\r\n    getStructOrUnion(name) {\r\n        return this.structOrUnion[name];\r\n    }\r\n\r\n    checkToken(type, contents) {\r\n        if(this.error) return false;\r\n        const token = this.currentToken;\r\n        if(token.type === type && (contents.length === 0 || contents.indexOf(token.content) !== -1)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    checkSign = (signs) => this.checkToken(_Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.sign, signs);\r\n\r\n    get currentLine() {\r\n        return this.#stream[this.parserIndex].line;\r\n    }\r\n\r\n    /**\r\n     * @returns {Boolean}\r\n     */\r\n    empty() {\r\n        return this.parserIndex >= this.#stream.length;\r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://Cpp4Web/./src/Fundamental/Parser.js?");

/***/ }),

/***/ "./src/Fundamental/Runtime.js":
/*!************************************!*\
  !*** ./src/Fundamental/Runtime.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Runtime: () => (/* binding */ Runtime)\n/* harmony export */ });\n/* harmony import */ var _Constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Constant */ \"./src/Fundamental/Constant.js\");\n/* harmony import */ var runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! runtime */ \"./src/Fundamental/RuntimeType.development.js\");\n\r\n\r\n\r\n\r\nconst createArray = (sizes, curr, defaultValue) => {\r\n    const ret = [];\r\n    if(curr + 1 == sizes.length) {\r\n        for(let i = 0; i < sizes[curr]; i++) {\r\n            ret.push(defaultValue);\r\n        }\r\n        return ret;\r\n    }\r\n    for(let i = 0; i < sizes[curr]; i++) {\r\n        ret.push(createArray(sizes, curr+1, defaultValue));\r\n    }\r\n    return ret;\r\n}\r\n\r\nclass Runtime {\r\n    /**\r\n     * @param {AST} AST \r\n     */\r\n    constructor(AST) {\r\n        this.AST = AST;\r\n        this.output = \"\";\r\n        this.stack = {arr: []};\r\n        this.symbolTable = new Map();\r\n        this.stack = [];\r\n        this.globalVariables = new Map();\r\n    }\r\n\r\n    setValue(exp1, exp2) {\r\n        let varibleName = exp1.content;\r\n        if(exp1.type === runtime__WEBPACK_IMPORTED_MODULE_1__.postfix) {\r\n            varibleName = varibleName.content;\r\n            const varibaleRaw = this.symbolTable.get(varibleName);\r\n            let variable = varibaleRaw;\r\n            \r\n            let postfix = exp1.sign;\r\n            while(postfix.inner !== null) {\r\n                const index = this.excute(postfix.parserIndex).result;\r\n                variable = variable[index];\r\n                postfix = postfix.inner;\r\n            }\r\n            const index = this.excute(postfix.parserIndex).result;\r\n            variable[index] = exp2;\r\n        } else {\r\n            this.symbolTable.set(varibleName, exp2);\r\n        }\r\n\r\n    }\r\n\r\n    binaryOp(exp1, exp2, sign) {\r\n        switch(sign) {\r\n            case '+':\r\n                return exp1.result+exp2.result;\r\n            case '-':\r\n                return exp1.result-exp2.result;\r\n            case '*':\r\n                return exp1.result*exp2.result;\r\n            case '/':\r\n                return exp1.result/exp2.result;\r\n            case '%':\r\n                return exp1.result%exp2.result;\r\n            case '<<':\r\n                return exp1.result<<exp2.result;\r\n            case '>>':\r\n                return exp1.result>>exp2.result;\r\n            case '^':\r\n                return exp1.result^exp2.result;\r\n            case '|':\r\n                return exp1.result|exp2.result;\r\n            case '||':\r\n                return exp1.result||exp2.result;\r\n            case '&&':\r\n                return exp1.result&&exp2.result;\r\n            case '&':\r\n                return exp1.result&exp2.result;\r\n            case '<':\r\n                return exp1.result<exp2.result?1:0;\r\n            case '>':\r\n                return exp1.result>exp2.result?1:0;\r\n            case '<=':\r\n                return exp1.result<=exp2.result?1:0;\r\n            case '>=':\r\n                return exp1.result>=exp2.result?1:0;\r\n            case '=':\r\n                this.setValue(exp1.result, exp2.result);\r\n                return exp2.result;\r\n            case '==':\r\n                return exp1.result==exp2.result?1:0;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {ForAST} currentNode \r\n     * @returns \r\n     */\r\n    excuteFor(currentNode) {\r\n        this.excute(currentNode.initial);\r\n        let condition = this.excute(currentNode.condition);\r\n        let currResult = null;\r\n        let currState = {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal};\r\n        while(condition.result != 0) {\r\n            const {state, result} = this.excute(currentNode.body);\r\n            if(state.controllState == _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.returnState) {\r\n                currResult = result;\r\n            }\r\n            if(state.controllState == _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.returnState || state.controllState == _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.breakState) {\r\n                currState = state;\r\n                break;\r\n            }\r\n            this.excute(currentNode.increment);\r\n            condition = this.excute(currentNode.condition);\r\n        }\r\n        if(currState.controllState == _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.breakState || currState.controllState == _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.continueState) {\r\n            currState.controllState = _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal;\r\n        }\r\n        return {result: currResult, state: currState};\r\n    }\r\n\r\n    /**\r\n     * @param {VariableAST} currentNode \r\n     * @returns \r\n     */\r\n    excuteVariable(currentNode) {\r\n        let variable = this.globalVariables.get(currentNode.content);\r\n        variable = this.symbolTable.get(currentNode.content);\r\n        return {result: variable, state: {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal}};\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {InvokeAST} node \r\n     * @returns \r\n     */\r\n    excuteBuildin(node) {\r\n        switch(node.functionName) {\r\n            case '@output':\r\n                for(const arg of node.argus) {\r\n                    const {result} = this.excute(arg);\r\n                    this.output += result;\r\n                }\r\n                break;\r\n            case '@arguments':\r\n                return {result: this.symbolTable.get('@arguments')}\r\n            case '@outputWithFormat':\r\n                {\r\n                    const {result: argus} = this.excute(node.argus[0]);\r\n                    const argument = argus;\r\n                    let output = argument[0];\r\n                    for(let i = 1; i < argument.length; i++) {\r\n                        output = output.replace('%d', argument[i]);\r\n                    }\r\n\r\n                    this.output += output;\r\n                }\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return {result: null, state: {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal}};\r\n    }\r\n\r\n    /**\r\n     * @param {ProgramAST} currentNode \r\n     * @returns \r\n     */\r\n    excuteProgram(currentNode) {\r\n        for(const gvariables of currentNode.globals) {\r\n            this.excute(gvariables);\r\n        }\r\n\r\n        this.globalVariables = this.symbolTable;\r\n        this.structs = currentNode.structs;\r\n        this.functionTable = currentNode.functions;\r\n        const {state} = this.excute(currentNode.main);\r\n        return {result : null, state};\r\n    }\r\n\r\n    /**\r\n     * @param {BlockAST} currentNode \r\n     * @returns \r\n     */\r\n    excuteBlock(currentNode) {\r\n        this.stack.push(\"block\");\r\n        let currentState = {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal};\r\n        let currentResut = null;\r\n        for(const child of currentNode.content) {\r\n            const {result, state} = this.excute(child);\r\n            if(state.controllState == _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.returnState) {\r\n                currentResut = result;\r\n            }\r\n            if(state.controllState != _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal) {\r\n                currentState = state;\r\n                break;\r\n            }\r\n        }\r\n        while(true) {\r\n            const last = this.stack.pop();\r\n            if(last == 'block')break;\r\n            this.symbolTable.delete(last);\r\n        }\r\n        return {result : currentResut, state: currentState};\r\n    }\r\n\r\n    /**\r\n     * @param {FunctionAST} currentNode \r\n     * @param {Object} argus \r\n     * @returns \r\n     */\r\n    excuteFunction(currentNode, argus) {\r\n        this.stack.push(currentNode.functionName);\r\n        const paras = currentNode.parameters;\r\n        const symbolTable = this.symbolTable;\r\n        this.symbolTable = new Map();\r\n        this.symbolTable.set(`@arguments`, argus);\r\n        for(let i = 0; i < paras.length; i++) {\r\n            const para = paras[i].variable.content;\r\n            if(para === '...') {\r\n                break;\r\n            }\r\n            this.stack.push(currentNode.functionName);\r\n            this.symbolTable.set(para, argus[i]);\r\n        }\r\n\r\n        const {state, result} = this.excute(currentNode.body);\r\n\r\n        while(true) {\r\n            const last = this.stack.pop();\r\n            if(last == currentNode.functionName)break;\r\n            this.symbolTable.delete(last);\r\n        }\r\n\r\n        this.symbolTable = symbolTable;\r\n        state.controllState = _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal;\r\n\r\n        return {result, state};\r\n    }\r\n\r\n    /**\r\n     * @param {ReturnAST} currentNode \r\n     * @returns \r\n     */\r\n    excuteReturn(currentNode) {\r\n        const {result} = this.excute(currentNode.content);\r\n        return {result, state: {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.returnState}};\r\n    }\r\n\r\n    /**\r\n     * @param {InvokeAST} currentNode \r\n     * @returns \r\n     */\r\n    excuteInvoke(currentNode) {\r\n        const func = this.functionTable.get(currentNode.functionName);\r\n        const argus = [];\r\n        for(const argu of currentNode.argus) {\r\n            const {result, state} = this.excute(argu);\r\n            argus.push(result);\r\n        }\r\n        const {result, state} = this.excute(func, argus);\r\n        return {result, state};\r\n    }\r\n\r\n    getType(type) {\r\n        if(type.type == runtime__WEBPACK_IMPORTED_MODULE_1__.arrayDeclearation) {\r\n            const length = this.excute(type.parserIndex).result;\r\n            const ret = [];\r\n            for(let i = 0; i < length; i++) {\r\n                ret.push(this.getType(type.inner));\r\n            }\r\n            return ret;\r\n        } else if(type.type == runtime__WEBPACK_IMPORTED_MODULE_1__.POD) {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {PostfixAST} currentNode \r\n     * @returns \r\n     */\r\n    excuteArray(currentNode) {\r\n        const varibleName = currentNode.content.content;\r\n        let arr = currentNode.sign;\r\n        const variable = this.symbolTable.get(varibleName);\r\n        let value = variable;\r\n        while(arr) {\r\n            const index = this.excute(arr.parserIndex).result;\r\n            value = value[index];\r\n            arr = arr.inner;\r\n        }\r\n        return {result: value, state: {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal}};\r\n    }\r\n\r\n    /**\r\n     * @param {DeclearationAST} currentNode \r\n     * @returns \r\n     */\r\n    excuteDeclearation(currentNode) {\r\n        for(const assignment of currentNode.content) {\r\n            const type = assignment[2];\r\n            const variable = assignment[0].content;\r\n            const defaultValue = this.getType(type);\r\n\r\n            if(assignment[1]) {\r\n                const exp = this.excute(assignment[1]);\r\n                this.symbolTable.set(variable, exp.result);\r\n            } else {\r\n                this.symbolTable.set(variable, defaultValue);\r\n            }\r\n\r\n            this.stack.push(variable);\r\n        }\r\n        return {result: null, state: {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal}};\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {Object} currentNode \r\n     * @param {Object | null} [argus=null]\r\n     * @returns \r\n     */\r\n    excute(currentNode, argus) {\r\n        switch(currentNode.type) {\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.program:\r\n                return this.excuteProgram(currentNode);\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.functionStmt:\r\n                return this.excuteFunction(currentNode,argus);\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.buildin:\r\n                return this.excuteBuildin(currentNode);\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.returnStmt:\r\n                return this.excuteReturn(currentNode);\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.string:\r\n                return {result: currentNode.content, state: {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal}};\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.invoke:\r\n                return this.excuteInvoke(currentNode);\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.breakStmt:\r\n                return {result : null, state: {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.breakState}};\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.continueStmt:\r\n                return {result : null, state: {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.continueState}};\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.blocks:\r\n                return this.excuteBlock(currentNode);\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.arrayDeclearation:\r\n                return this.excuteBlock(currentNode);\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.array:\r\n                return this.excuteArray(currentNode);\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.binaryOp:\r\n                {\r\n                    const exp1 = this.excute(currentNode.content[0]);\r\n                    const exp2 = this.excute(currentNode.content[1]);\r\n                    const result = this.binaryOp(exp1, exp2, currentNode.sign);\r\n                    return {result, state: {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal}};\r\n                }\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.number:\r\n                return {result: parseInt(currentNode.content), state: {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal}};\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.declearation:\r\n                return this.excuteDeclearation(currentNode);\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.variable:\r\n                return this.excuteVariable(currentNode);\r\n\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.lValue:\r\n                return {result: currentNode.content, state: {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal}};\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.lValue:\r\n                {\r\n                    const {state, result: variable} = this.excute(currentNode.name);\r\n                    let ele = variable;\r\n\r\n                    for(const index of currentNode.arr) {\r\n                        const {state, result} = this.excute(index);\r\n                        ele = ele[result];\r\n                    }\r\n\r\n                    return {result: ele, state};\r\n                }\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.ifStmt:\r\n                {\r\n                    const condition = this.excute(currentNode.condition);\r\n                    if(condition.result != 0) {\r\n                        return this.excute(currentNode.body);\r\n                    }\r\n                    if(currentNode.elif)\r\n                        for(const elif of currentNode.elif) {\r\n                            const condition = this.excute(elif.condition);\r\n                            if(condition.result != 0) {\r\n                                return this.excute(elif.body);\r\n                            }\r\n                        }\r\n                    \r\n                    if(currentNode.elses) {\r\n                        return this.excute(currentNode.elses);\r\n                    }\r\n                }\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.whileStmt:\r\n                {\r\n                    let condition = this.excute(currentNode.condition);\r\n                    let currState = {controllState: _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal};\r\n                    let currResult = null;\r\n                    while(condition.result != 0) {\r\n                        const {state, result} = this.excute(currentNode.body);\r\n                        currState = state;\r\n                        if(state.controllState == _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.returnState) {\r\n                            currResult = result;\r\n                        }\r\n                        if(state.controllState == _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.returnState || state.controllState == _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.breakState)break;\r\n                        condition = this.excute(currentNode.condition);\r\n                    }\r\n                    if(currState.controllState == _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.breakState || currState.controllState == _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.continueState) {\r\n                        currState.controllState = _Constant__WEBPACK_IMPORTED_MODULE_0__.ControllType.normal;\r\n                    }\r\n                    return {result: currResult, state: currState};\r\n                }\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.forStmt:\r\n                return this.excuteFor(currentNode);\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.postfix: \r\n                {\r\n                    if(currentNode.sign == '++') {\r\n                        const content = this.excute(currentNode.content);\r\n                        this.symbolTable.set(currentNode.content.content, content.result+1);\r\n                        return {result: content.result, state: content.state};\r\n                    } else if(currentNode.sign == '--') {\r\n                        const content = this.excute(currentNode.content);\r\n                        this.symbolTable.set(currentNode.content.content, content.result-1);\r\n                        return {result: content.result, state: content.state};\r\n                    } else {\r\n                        return this.excuteArray(currentNode);\r\n                    }\r\n                }\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.prefix: \r\n                {\r\n                    if(currentNode.sign == '++') {\r\n                        const content = this.excute(currentNode.content);\r\n                        this.symbolTable.set(currentNode.content.content, content.result+1);\r\n                        return {result: content.result, state: content.state};\r\n                    }\r\n                    if(currentNode.sign == '--') {\r\n                        const content = this.excute(currentNode.content);\r\n                        this.symbolTable.set(currentNode.content.content, content.result-1);\r\n                        return {result: content.result, state: content.state};\r\n                    }\r\n                    if(currentNode.sign == '-') {\r\n                        const content = this.excute(currentNode.content);\r\n                        return {result: -content.result, state: content.state};\r\n                    }\r\n                    if(currentNode.sign == '+') {\r\n                        const content = this.excute(currentNode.content);\r\n                        return {result: content.result, state: content.state};\r\n                    }\r\n                }\r\n            case runtime__WEBPACK_IMPORTED_MODULE_1__.ternaryOp:\r\n                {\r\n                    if(currentNode.sign == '?') {\r\n                        const condition = this.excute(currentNode.content[0]);\r\n                        if(condition.result > 0) {\r\n                            const content = this.excute(currentNode.content[1]);\r\n                            return {result: content.result, state: content.state};\r\n                        } else {\r\n                            const content = this.excute(currentNode.content[2]);\r\n                            return {result: content.result, state: content.state};\r\n                        }\r\n                    }\r\n                }\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} input \r\n     * @param {*} config \r\n     * @returns \r\n     */\r\n    launch(input, config) {\r\n        this.input = input;\r\n        this.excute(this.AST);\r\n        return {output: this.output.replaceAll('\\\\n', '\\n')};\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://Cpp4Web/./src/Fundamental/Runtime.js?");

/***/ }),

/***/ "./src/Fundamental/RuntimeType.development.js":
/*!****************************************************!*\
  !*** ./src/Fundamental/RuntimeType.development.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POD: () => (/* binding */ POD),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   arrayDeclearation: () => (/* binding */ arrayDeclearation),\n/* harmony export */   binaryOp: () => (/* binding */ binaryOp),\n/* harmony export */   blocks: () => (/* binding */ blocks),\n/* harmony export */   breakStmt: () => (/* binding */ breakStmt),\n/* harmony export */   buildin: () => (/* binding */ buildin),\n/* harmony export */   continueStmt: () => (/* binding */ continueStmt),\n/* harmony export */   declearation: () => (/* binding */ declearation),\n/* harmony export */   doStmt: () => (/* binding */ doStmt),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   forStmt: () => (/* binding */ forStmt),\n/* harmony export */   functionStmt: () => (/* binding */ functionStmt),\n/* harmony export */   ifStmt: () => (/* binding */ ifStmt),\n/* harmony export */   invoke: () => (/* binding */ invoke),\n/* harmony export */   lValue: () => (/* binding */ lValue),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   postfix: () => (/* binding */ postfix),\n/* harmony export */   prefix: () => (/* binding */ prefix),\n/* harmony export */   program: () => (/* binding */ program),\n/* harmony export */   property: () => (/* binding */ property),\n/* harmony export */   returnStmt: () => (/* binding */ returnStmt),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   ternaryOp: () => (/* binding */ ternaryOp),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   variable: () => (/* binding */ variable),\n/* harmony export */   whileStmt: () => (/* binding */ whileStmt)\n/* harmony export */ });\nconst variable = \"variable\";\r\nconst binaryOp = \"binaryOp\";\r\n\r\nconst array = \"array\";\r\n\r\nconst arrayDeclearation = \"arrayDeclearation\";\r\nconst prefix = \"prefix\";\r\nconst ternaryOp = \"ternaryOp\";\r\n\r\nconst declearation = \"declearation\";\r\n\r\nconst forStmt = \"forStmt\";\r\n\r\nconst doStmt = \"doStmt\";\r\n\r\nconst breakStmt = \"breakStmt\";\r\nconst continueStmt = \"continueStmt\";\r\n\r\nconst returnStmt = \"returnStmt\";\r\n\r\nconst blocks = \"block\";\r\n\r\nconst functionStmt = \"function\";\r\n\r\nconst program = \"program\";\r\n\r\nconst buildin = \"buildin\";\r\n\r\nconst invoke = \"invoke\";\r\nconst whileStmt = \"whileStmt\";\r\n\r\nconst number = \"number\";\r\n\r\nconst empty = \"empty\";\r\n\r\nconst type = \"type\";\r\n\r\nconst POD = \"POD\";\r\n\r\nconst struct = \"struct\";\r\n\r\nconst string = \"string\";\r\n\r\nconst ifStmt = \"if\";\r\n\r\nconst postfix = \"postfix\";\r\n\r\nconst lValue = \"lValue\";\r\n\r\nconst property = \"property\";\n\n//# sourceURL=webpack://Cpp4Web/./src/Fundamental/RuntimeType.development.js?");

/***/ }),

/***/ "./src/Fundamental/Tokenizer.js":
/*!**************************************!*\
  !*** ./src/Fundamental/Tokenizer.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tokenizer: () => (/* binding */ Tokenizer)\n/* harmony export */ });\n/* harmony import */ var _Constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Constant */ \"./src/Fundamental/Constant.js\");\n/* harmony import */ var _Header_cstdio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Header/cstdio */ \"./src/Header/cstdio.js\");\n\r\n\r\n\r\n/**\r\n * Tokenizes a raw string of code.\r\n *\r\n * @param {string} str - The input string to tokenize.\r\n * @returns {{type: number, content: string, len: number}} An array containing the token information.\r\n *          Each token is represented as an object with a 'type' (e.g., 'char') and 'content' (e.g., 'a').\r\n */\r\nconst getNextToken = (str) => {\r\n\r\n    const numberRex = /^((\\d+\\.\\d*|\\.\\d+|\\d+)([eE][-+]?\\d+)?[lLuU]*)|^(0[xX][0-9a-fA-F]+[lLuU]*)|^(0[0-7]+[lLuU]*)/\r\n    if(str.startsWith(\";\")) {\r\n        return {type: _Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.semicolon, content: \";\", len: 1};\r\n    }\r\n\r\n    if(str.startsWith('\"')) {\r\n        for(let i = 1; i < str.length; i++) {\r\n            if(str[i] == '\"' && str[i-1] != \"\\\\\") {\r\n                let result = str.slice(1, i).replaceAll();\r\n                return {type: _Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.string, content: result, len: i+1};\r\n            }\r\n        }\r\n    }\r\n\r\n    if(str.startsWith(\"'\")) {\r\n        return {type: _Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.char, content: str[1], len: 3};\r\n    }\r\n    if(str.startsWith(\"#\")) {\r\n        return {type: \"preCompile\", len: 1};\r\n    }\r\n\r\n    if(str.startsWith(\"/*\")) {\r\n        return {type: \"comment\", content: \"/*\", len: 2};\r\n    }\r\n\r\n\r\n    if(/^[\\s]+/.test(str)) {\r\n        const space = str.match(/^[\\s]+/);\r\n        return {type: \"whiteSpace\", content: space, len: space.length};\r\n    }\r\n\r\n    if(str.startsWith(\"//\")) {\r\n        return {type: \"comment\", content: \"//\", len: str.length};\r\n    }\r\n\r\n    if(numberRex.test(str)) {\r\n        const number = str.match(numberRex)[0];\r\n        return {type: _Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.number, content: number, len: number.length};\r\n    }\r\n\r\n    if(/^[_a-zA-Z][_a-zA-Z0-9]*/.test(str)) {\r\n        const identifier = str.match(/^[_a-zA-Z][_a-zA-Z0-9]*/)[0];\r\n        if(_Constant__WEBPACK_IMPORTED_MODULE_0__.keyWords.indexOf(identifier) !== -1) {\r\n            return {type: _Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.keyword, content: identifier, len: identifier.length};\r\n        }\r\n        return {type: _Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.identifier, content: identifier, len: identifier.length};\r\n    }\r\n\r\n    if(/^\\@[_a-zA-Z][_a-zA-Z0-9]*/.test(str)) {\r\n        const identifier = str.match(/^\\@[_a-zA-Z][_a-zA-Z0-9]*/)[0];\r\n        return {type: _Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.buildin, content: identifier, len: identifier.length};\r\n    }\r\n\r\n    for(const sign of _Constant__WEBPACK_IMPORTED_MODULE_0__.signs) {\r\n        if(str.startsWith(sign)) {\r\n            return {type: _Constant__WEBPACK_IMPORTED_MODULE_0__.TokenType.sign, content: sign, len: sign.length};\r\n        }\r\n    }\r\n}\r\n\r\nconst getLine = (para) => {\r\n    while(para.line !== '') {\r\n        if(para.blockComment) {\r\n            let i = 1;\r\n            for(; i < para.line.length; i++) {\r\n                if(para.line[i] == '/' && para.line[i-1] == '*') {\r\n                    para.blockComment = false;\r\n                    break;\r\n                }\r\n            }\r\n            para.line = para.line.slice(i+1);\r\n            if(para.line === '')break;\r\n        }\r\n        const tokenArr = getNextToken(para.line);\r\n        if(tokenArr.type == 'preCompile') {\r\n            return 1;\r\n        }\r\n        const token = tokenArr;\r\n        if(token.type != \"whiteSpace\" && token.type != \"comment\") {\r\n            token.line = para.lineNum;\r\n            para.stream.push(token);\r\n        } else if(token.content === '/*') {\r\n            para.blockComment = true;\r\n        }\r\n        para.line = para.line.slice(tokenArr.len);\r\n    }\r\n    return 0;\r\n}\r\n\r\nconst preCompile = (stream, stream2) => {\r\n    let index = 0;\r\n    switch(stream[index].content) {\r\n        case \"include\":\r\n            index++;\r\n            if(stream[index].content == '<')index++;\r\n            const para = {\r\n                lineNum: 1,\r\n                blockComment: false,\r\n                stream: stream2\r\n            };\r\n            const headerList = {\r\n                \"cstdio\": _Header_cstdio__WEBPACK_IMPORTED_MODULE_1__.cstdio,\r\n                \"stdio\": _Header_cstdio__WEBPACK_IMPORTED_MODULE_1__.cstdio\r\n            };\r\n            const header = headerList[stream[index].content];\r\n            const lines = header.split('\\n');\r\n\r\n            for(const line of lines) {\r\n                para.line = line;\r\n                getLine(para);\r\n            }\r\n\r\n            return;\r\n        \r\n        case \"define\":\r\n            index++;\r\n            return;\r\n        \r\n    }\r\n}\r\n\r\nconst Tokenizer = (rawCode) => {\r\n    const lines = rawCode.split('\\n');\r\n    const para = {\r\n        lineNum: 1,\r\n        blockComment: false,\r\n        stream: []\r\n    };\r\n    for(const lineRow of lines) {\r\n        para.line = lineRow;\r\n        const isPreCompile = getLine(para);\r\n        if(isPreCompile) {\r\n            const stream = para.stream;\r\n            para.stream = [];\r\n            para.line = para.line.slice(1);\r\n            getLine(para);\r\n            preCompile(para.stream, stream);\r\n\r\n            para.stream = stream;\r\n        }\r\n        para.lineNum++;\r\n    }\r\n    return para.stream;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://Cpp4Web/./src/Fundamental/Tokenizer.js?");

/***/ }),

/***/ "./src/Header/cstdio.js":
/*!******************************!*\
  !*** ./src/Header/cstdio.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cstdio: () => (/* binding */ cstdio)\n/* harmony export */ });\nconst cstdio = `\r\nvoid puts(string out) {\r\n    @output(out);\r\n}\r\n\r\nvoid printf(string out) {\r\n    @outputWithFormat( @arguments() );\r\n}\r\n\r\n`;\r\n\r\n\n\n//# sourceURL=webpack://Cpp4Web/./src/Header/cstdio.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Parse: () => (/* reexport safe */ _Fundamental_ParseFunctions__WEBPACK_IMPORTED_MODULE_0__.Parse),\n/* harmony export */   Runtime: () => (/* reexport safe */ _Fundamental_Runtime__WEBPACK_IMPORTED_MODULE_2__.Runtime),\n/* harmony export */   Tokenizer: () => (/* reexport safe */ _Fundamental_Tokenizer__WEBPACK_IMPORTED_MODULE_1__.Tokenizer)\n/* harmony export */ });\n/* harmony import */ var _Fundamental_ParseFunctions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Fundamental/ParseFunctions */ \"./src/Fundamental/ParseFunctions.js\");\n/* harmony import */ var _Fundamental_Tokenizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Fundamental/Tokenizer */ \"./src/Fundamental/Tokenizer.js\");\n/* harmony import */ var _Fundamental_Runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Fundamental/Runtime */ \"./src/Fundamental/Runtime.js\");\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://Cpp4Web/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});